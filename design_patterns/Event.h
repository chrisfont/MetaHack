#pragma once

#include "Serializable.h"
#include "utilities/New.h"

// Forward declarations
class Object;

enum EventID : size_t
{
  AutoGenerated,
  All
};

inline std::ostream& operator<<(std::ostream& os, EventID const& eventID)
{
  os << std::setiosflags(std::ios::showbase)
    << std::setbase(16) 
    << std::setfill('0') 
    << std::setw(8) 
    << static_cast<size_t>(eventID)
    << std::setw(0) 
    << std::setbase(10)
    << std::resetiosflags(std::ios::showbase);
  return os;
}

/// Event declaration for observer pattern.
/// Adapted from http://0xfede.io/2015/12/13/T-C++-ObserverPattern.html
class Event : public virtual Serializable
{

public:
  static const EventID id;

  virtual ~Event() = default;

  virtual Event* heapClone() const = 0;
  virtual EventID getId() const;

  Object* subject;

  void serialize(std::ostream& os) const;
};

template <class T, EventID eID = EventID::AutoGenerated>
class ConcreteEvent : public Event
{

public:
  /// Clone an event on the heap.
  Event* heapClone() const
  {
    return NEW T(static_cast<T const&>(*this));
  }

  /// Get the ID of this event.
  EventID getId() const
  {
    return id;
  }

  static EventID const id;
  //static char* const name;
};

template <class T, EventID eID>
EventID const ConcreteEvent<T, eID>::id =
  eID != EventID::AutoGenerated ? eID : (EventID)(typeid(T).hash_code());

//template <class T, EventID eID>
//char* const ConcreteEvent<T, eID>::name = typeid(T).name();