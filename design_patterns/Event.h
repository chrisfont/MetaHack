#pragma once

#include "Serializable.h"
#include "utilities/New.h"

// Forward declarations
class Subject;

enum EventID : size_t
{
  AutoGenerated,
  All
};

/// Event declaration for observer pattern.
/// Adapted from http://0xfede.io/2015/12/13/T-C++-ObserverPattern.html
class Event : public virtual Serializable
{

public:
  static const EventID id;

  virtual ~Event() = default;

  virtual Event* heapClone() const = 0;
  virtual EventID getId() const;

  Subject* subject;

  void serialize(std::ostream& os) const;
};

template <class T, class B = Event, EventID eID = EventID::AutoGenerated>
class ConcreteEvent : public B
{
  static_assert(std::is_base_of<Event, B>::value, "");

public:
  /// Get the ID of a particular event type.
  static EventID id();

  /// Clone an event on the heap.
  Event* heapClone() const;

  /// Get the ID of a particular event.
  EventID getId() const;

private:
  /// Do NOT use this to get the ID of individual events, only that of
  /// event classes. It won't return the right ID otherwise.
  static const EventID m_id;
};

template <class T, class B, EventID eID>
const EventID ConcreteEvent<T, B, eID>::m_id =
eID != EventID::AutoGenerated ? eID : (EventID)typeid(T).hash_code();

template <class T, class B, EventID eID>
EventID ConcreteEvent<T, B, eID>::getId() const
{
  return m_id;
}

template <class T, class B, EventID eID>
EventID ConcreteEvent<T, B, eID>::id()
{
  return m_id;
}

template <class T, class B, EventID eID>
Event* ConcreteEvent<T, B, eID>::heapClone() const
{
  return NEW T(static_cast<T const&>(*this));
}