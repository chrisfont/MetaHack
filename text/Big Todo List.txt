BIG TODO LIST

SMALL THINGS
============
[ ] Feature: If nothing is selected and ']' is pressed, auto-select @ (you).
[ ] Add Lua function "get_property_name_XXXX" for properties, so they can be added to Thing descriptions in a sensible manner (e.g. "a blind cave bat", but not "a blind dagger"
[ ] Add Lua functions "on_base_property_change_XXX", "on_transient_property_change_XXX" for when Thing properties are modified. Pass in the old value and the new value.
[ ] Export "thing_set_quantity" / "thing_modify_quantity" functions to Lua
[ ] BUG: Using "/" look command reveals inventory of squares player can't see
[ ] BUG: HP display in status area is screwed up
[ ] Look at some of the intrinsics like "movable", "lockable", et cetera and see if they can be removed.
    e.g. "lockable" can be replaced by "can_have_action_lock_done_by(nil)"

MEDIUM THINGS
=============
[X] Get rid of all singletons except for the App singleton.
[ ] When a StringDisplay is passed to/from Lua, it should be automatically converted between UTF-8 and UTF-16 as appropriate.
[ ] Have StringDisplay be an alias for std::wstring instead of sf::String, in order to decouple a bit from SFML
[ ] Add a function that allows for automatic substitution of substrings, instead of concatenating macros as is done now. This will be needed for easy creation of display strings in Lua.
    [ ] Export said function to Lua
[/] Transient properties
    [/] Cached set of properties
        - Property is recalculated upon:
            - base property changing
            - add_property_modifier / remove_property_modifier
            - modifier expiration
    [X] Map of modifiers for a base property:
        - ID of thing responsible for modifier
        - Lua function to call to modify the property
        - Number of ticks modifier stays in place, or 0 if permanent until explicitly removed
    [X] Export "add_property_modifier", "remove_property_modifier" to Lua
        - Either of these causes a recalculation of transient property values

[ ] Rewrite autobind code using new property modifiers
[ ] Rewrite LightSource lighting code using new property modifiers
[ ] Write attire (wear) action code
[ ] Write open, close Action code
[ ] Write lock, unlock Action code
[ ] Transition die code into Action subclass (?)
[ ] Some more verbs: clean, push, shatter(?), unwield
[ ] Create (and call) each Thing's "process()" Lua function (needed for enemy AI!)
[ ] Create Lua functions to allow queuing of Actions (needed for enemy AI!)
[ ] Fix quantities (they are not currently being respected for get/drop actions)
[X] Death conditions
    [/] For player
        - Player do_die() is called, but graceful game shutdown is not yet done
    [X] For other Things
[ ] Make it easier for enum classes to be defined, to have an operator<< defined, and to have it exposed to Lua.
[ ] Replace the error/trace functions with boost logging facilities
[ ] Light bleed across tiles
    - Simple convolution that bleeds a bit of light from a tile into adjacent ones, will make shadows way less sharp
[/] Split MessageLog into model/view (MessageLog and MessageLogPane)
[ ] Allow for scrolling back in MessageLog
[ ] Allow for lines with different colors (and fonts?) in MessageLog
[/] Show the "wielded" / "equipped" tiles in the Inventory
    - Doing a simple letter so far, will do nicer tiles down the line
    
[/] Create Thing::spill() method which dumps the contents of a Thing out into the Thing's location
    - Maybe allow a "do_spill" action that performs this purposely?
    - Each Thing that tumbles out should have do_collided_with(new_location) called on it (do_collided_with_floor?)

BIG THINGS
==========
[/] Implement GUILabel class
    [ ] Label should support left/center/right justification
    [ ] Label should handle text wrapping
    [ ] Change StatusArea to use GUILabel
    [ ] Change InventoryArea to use GUILabel

[/] Map creation driven via Lua scripts instead of C++ code

[ ] Add a way for monster types to register themselves in a vector that stores spawn information
    - Never / Single / Group
    - XP level for spawning
    - Spawn location (e.g. cave, town, etc)?
    
[ ] Implement the Attack action!

[ ] Let Lua get a Thing's inventory (as a table of ids)

[ ] Streamline Lua get/set of properties
    - We shouldn't require these get_[flag|value|string] functions for Lua; we should just be able to call get/set and have the C function deduce what we want. For setting:
        - 1 lua_Number --> value
        - 1 lua_Boolean --> bool
        - 1 lua_String --> string
        - 2 lua_Numbers --> sf::Vector2f
        - 4 lua_Numbers --> sf::Color
        
    - Likewise, get can just push back however many return values are needed for the value.

[X] Revamp Actions
    - Actions should be split into the following stages:
        - "pending": The action is ready to be executed.
        - "pre_begin": Prior to the action being executed. Checks to see if the action is possible. Accounts for overall reaction time (based on Agility attribute) and waits before starting the action.
        - "in_progress": Starts the action; waits for the amount of time the action takes to execute. Switches to "post_finish" when completed.
        - "post_finish": Completes the action; waits for the recovery time after the action is completed. Switches to "processed".
        - "processed": Action is done, and the next action should be popped.
    
    - Some actions have to be fudged; for example, "move". Obviously, in real life, the move would start at "begin", progress from tile A to tile B during "in_progress", and end up at "finish". However, being a tile-based game, moves are atomic from tile to tile. So the move immediately executes at the start of "in_progress". "in_progress" is the amount of time the move actually took. "post_finish" does nothing. This will best approximate what the player expects to happen -- if a monster is adjacent, about to attack, they can leap out of the way. (Of course, there's still the "pre_begin" Agility check, so they may not be fast enough.)

[ ] Mouse selection of GUIPanes, inventory items

[ ] List of available commands that apply when Things are selected
        
[ ] GUIPane animation for sliding in/out, flipping, expanding/shrinking

[ ] Settings option that chooses which attributes to show in StatusArea

[ ] Implement fog / variable opacity for sight
    - This actually isn't too difficult; we already have the "depth" parameter for do_recursive_visibility. It wouldn't be too hard to add a combined opacity number, and bail out if it exceeds a certain value.

[ ] Use std::async to parallelize visibility, light propogation
    - Requires making sure that the algorithm does not visit any one tile twice. Right now I think the 45/90-degree compass directions ARE visited twice, which would have to be rectified.
    - After that it should be as simple as wrapping octant calls inside std::async
    
MIND-BOGGLINGLY ENORMOUS THINGS
===============================
[ ] Implement saving/loading of the entire game state
[ ] Refactor rendering to allow for swapping out rendering engines

??? THINGS
==========
    - How do we handle polymorphing?
        - A permanent polymorph is actually pretty easy; you just make a new Thing and then do set_player() on it.
        - Temporary polymorphs are far trickier; we need a way to stash the existing Thing somewhere, and then revert back to it at death.
            - Original form could be stashed in Limbo; the temporary polymorph would need to store its ThingId to know what to revert to
            - There's also the question of which attributes get copied over.
