SMALL THINGS
============
[ ] Lua-ify some more events and checks
[ ] Fix quantities (they are not currently being respected for get/drop actions)
[ ] Export "thing_set_quantity" / "thing_modify_quantity" functions to Lua
[ ] Export "thing_destroy" function to Lua

MEDIUM THINGS
=============
[X] Have the Lua "map.lua" script place the initial things
[ ] Make it easier for enum classes to be defined, to have an operator<< defined, and to have it exposed to Lua.
[ ] Replace the error/trace functions with boost logging facilities
[ ] Light bleed across tiles
    - Simple convolution that bleeds a bit of light from a tile
      into adjacent ones, will make shadows way less sharp
[ ] Split MessageLog into model/view (MessageLog and MessageLogPane)
[ ] Allow for scrolling back in MessageLog
[ ] Allow for lines with different colors (and fonts?) in MessageLog
[/] Show the "wielded" / "equipped" tiles in the Inventory
    - Doing a simple letter so far, will do nicer tiles down the line
    
[/] Create Thing::spill() method which dumps the contents of a Thing out into the Thing's location
    - Maybe allow a "do_spill" action that performs this purposely?
    - Each Thing that tumbles out should have do_collided_with(new_location) called on it

BIG THINGS
==========
[ ] Implement GUILabel class
    [ ] Label should support left/center/right justification
    [ ] Label should handle text wrapping
    [ ] Change StatusArea to use GUILabel
    [ ] Change InventoryArea to use GUILabel

[/] Map creation driven via Lua scripts instead of C++ code

[ ] Add a way for monster types to register themselves in a vector that stores spawn information
    - Never / Single / Group
    - Player XP level for spawning
    - Spawn location (e.g. cave, town, etc)?
    
[ ] Implement the Attack action!

[ ] Let Lua get a Thing's inventory (as a table of ids)

[ ] Streamline Lua get/set of properties
    - We shouldn't require these get_[flag|value|string] functions for Lua; we should just be able to call get/set and have the C function deduce what we want. For setting:
        - 1 lua_Number --> value
        - 1 lua_Boolean --> bool
        - 1 lua_String --> string
        - 2 lua_Numbers --> sf::Vector2f
        - 4 lua_Numbers --> sf::Color
        
    - Likewise, get can just push back however many return values are needed for the value.

[ ] Revamp Actions
    - Right now, actions just execute immediately when popped from the queue, and then have an "action_time" where the actor is frozen.
    - Instead, actions should be split into the following stages:
        - "pending": The action is ready to be executed.
        - "pre_begin": Prior to the action being executed. Accounts for overall reaction time (based on Agility attribute).
        - "begin": When the action is first executed. Switches to "in_progress".
        - "in_progress": While the action is executing. Switches to "finish" when completed.
        - "finish": When the action is completed. Switches to "post_finish".
        - "post_finish": Recovery time after the action is completed. Switches to "processed".
        - "processed": Action is done, and the next action should be popped.
    
    - Some actions have to be fudged; for example, "move". Obviously, in real life, the move would start at "begin", progress from tile A to tile B during "in_progress", and end up at "finish". However, being a tile-based game, moves are atomic from tile to tile. So the move mmediately execute on "begin". "in_progress" is the amount of time the move actually took. Nothing happens on "finish", and "post_finish" stays at zero. This will best approximate what the player expects to happen -- if a monster is adjacent, about to attack, they can leap out of the way. (Of course, there's still the "pre_begin" Agility check, so they may not be fast enough.)

[ ] Mouse selection of GUIPanes, inventory items

[ ] List of available commands that apply when Things are selected
        
[ ] GUIPane animation for sliding in/out, flipping, expanding/shrinking

[ ] Settings option that chooses which attributes to show in StatusArea

MIND-BOGGLINGLY ENORMOUS THINGS
===============================
[ ] Implement saving/loading of the dungeon


??? THINGS
==========
    - How do we handle polymorphing?
        - A permanent polymorph is actually pretty easy; you just make a new Thing and then do set_player() on it.
        - Temporary polymorphs are far trickier; we need a way to stash the existing Thing somewhere, and then revert back to it at death.
            - Original form could be stashed in Limbo; the temporary polymorph would need to store its ThingId to know what to revert to
            - There's also the question of which attributes get copied over.
