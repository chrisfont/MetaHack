SMALL THINGS
============
[ ] Lua-ify some more events and checks (which ones?)
[ ] Export "thing_set_quantity" / "thing_modify_quantity" functions to Lua
[X] Re-implement Lua "get_intrinsic_XXX" functions for Things

MEDIUM THINGS
=============
[ ] Fix quantities (they are not currently being respected for get/drop actions)
[X] Death conditions
    [/] For player
        - Player do_die() is called, but graceful game shutdown is not yet done
    [X] For other Things
[ ] Make it easier for enum classes to be defined, to have an operator<< defined, and to have it exposed to Lua.
[ ] Replace the error/trace functions with boost logging facilities
[ ] Light bleed across tiles
    - Simple convolution that bleeds a bit of light from a tile into adjacent ones, will make shadows way less sharp
[/] Split MessageLog into model/view (MessageLog and MessageLogPane)
[ ] Allow for scrolling back in MessageLog
[ ] Allow for lines with different colors (and fonts?) in MessageLog
[/] Show the "wielded" / "equipped" tiles in the Inventory
    - Doing a simple letter so far, will do nicer tiles down the line
    
[/] Create Thing::spill() method which dumps the contents of a Thing out into the Thing's location
    - Maybe allow a "do_spill" action that performs this purposely?
    - Each Thing that tumbles out should have do_collided_with(new_location) called on it (do_collided_with_floor?)

BIG THINGS
==========
[/] Implement GUILabel class
    [ ] Label should support left/center/right justification
    [ ] Label should handle text wrapping
    [ ] Change StatusArea to use GUILabel
    [ ] Change InventoryArea to use GUILabel

[/] Map creation driven via Lua scripts instead of C++ code

[ ] Add a way for monster types to register themselves in a vector that stores spawn information
    - Never / Single / Group
    - XP level for spawning
    - Spawn location (e.g. cave, town, etc)?
    
[ ] Implement the Attack action!

[ ] Let Lua get a Thing's inventory (as a table of ids)

[ ] Streamline Lua get/set of properties
    - We shouldn't require these get_[flag|value|string] functions for Lua; we should just be able to call get/set and have the C function deduce what we want. For setting:
        - 1 lua_Number --> value
        - 1 lua_Boolean --> bool
        - 1 lua_String --> string
        - 2 lua_Numbers --> sf::Vector2f
        - 4 lua_Numbers --> sf::Color
        
    - Likewise, get can just push back however many return values are needed for the value.

[/] Revamp Actions
    - Actions should be split into the following stages:
        - "pending": The action is ready to be executed.
        - "pre_begin": Prior to the action being executed. Checks to see if the action is possible. Accounts for overall reaction time (based on Agility attribute) and waits before starting the action.
        - "in_progress": Starts the action; waits for the amount of time the action takes to execute. Switches to "post_finish" when completed.
        - "post_finish": Completes the action; waits for the recovery time after the action is completed. Switches to "processed".
        - "processed": Action is done, and the next action should be popped.
    
    - Some actions have to be fudged; for example, "move". Obviously, in real life, the move would start at "begin", progress from tile A to tile B during "in_progress", and end up at "finish". However, being a tile-based game, moves are atomic from tile to tile. So the move immediately executes at the start of "in_progress". "in_progress" is the amount of time the move actually took. "post_finish" does nothing. This will best approximate what the player expects to happen -- if a monster is adjacent, about to attack, they can leap out of the way. (Of course, there's still the "pre_begin" Agility check, so they may not be fast enough.)

[ ] Mouse selection of GUIPanes, inventory items

[ ] List of available commands that apply when Things are selected
        
[ ] GUIPane animation for sliding in/out, flipping, expanding/shrinking

[ ] Settings option that chooses which attributes to show in StatusArea

[ ] Implement fog / variable opacity for sight
    - This actually isn't too difficult; we already have the "depth" parameter for do_recursive_visibility. It wouldn't be too hard to add a combined opacity number, and bail out if it exceeds a certain value.

[ ] Use std::async to parallelize visibility, light propogation
    - Requires making sure that the algorithm does not visit any one tile twice. Right now I think the 45/90-degree compass directions ARE visited twice, which would have to be rectified.
    - After that it should be as simple as wrapping octant calls inside std::async
    
MIND-BOGGLINGLY ENORMOUS THINGS
===============================
[ ] Switch over to using SFGUI for GUI elements (or some other GUI engine)

[ ] Implement saving/loading of the entire game state


??? THINGS
==========
    - How do we handle polymorphing?
        - A permanent polymorph is actually pretty easy; you just make a new Thing and then do set_player() on it.
        - Temporary polymorphs are far trickier; we need a way to stash the existing Thing somewhere, and then revert back to it at death.
            - Original form could be stashed in Limbo; the temporary polymorph would need to store its ThingId to know what to revert to
            - There's also the question of which attributes get copied over.
