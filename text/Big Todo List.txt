BIG TODO LIST

REQUIRED LUA FUNCTIONS
======================
[ ] Add Lua functions "on_base_property_change_XXX", "on_transient_property_change_XXX" for when Thing properties are modified. Pass in the old value and the new value.
[ ] Export "thing_set_quantity" / "thing_modify_quantity" functions to Lua
[ ] Add Lua function "get_property_name_XXXX" for properties, so they can be added to Thing descriptions in a sensible manner (e.g. "a blind cave bat", but not "a blind dagger"
	-- Is this really needed?
[ ] Export "generate_string" string builder function to Lua (see below)
[ ] Create Lua functions to allow queuing of Actions (needed for enemy AI!)
[ ] Export functions so enemy AI is able to sense its environment (e.g. ability to access memory, senses)

SMALL THINGS
============
[ ] Feature: If nothing is selected and ']' is pressed, auto-select @ (you).
[ ] BUG: Using "/" look command reveals inventory of squares player can't see
[ ] Look at some of the intrinsics like "movable", "lockable", et cetera and see if they can be removed.
    e.g. "lockable" can be replaced by "can_have_action_lock_done_by(nil)"
[ ] Use boost::time_duration for representing in-game time.

MEDIUM THINGS
=============
[X] Add a "generate_string" function that allows for automatic substitution of substrings, instead of concatenating macros as is done now. This will be needed for easy creation of display strings in Lua.

[X] Add the ability to pass Direction to/from Lua
    - Required if Direction enums will be stored as properties

[/] Transient properties
    [/] Cached set of properties
        - Property is recalculated upon:
            - base property changing
            - add_property_modifier / remove_property_modifier
            - modifier expiration
    [X] Map of modifiers for a base property:
        - ID of thing responsible for modifier
        - Lua function to call to modify the property
        - Number of ticks modifier stays in place, or 0 if permanent until explicitly removed
    [X] Export "add_property_modifier", "remove_property_modifier" to Lua
        - Either of these causes a recalculation of transient property values

[ ] Rewrite autobind code using new property modifiers
[ ] Rewrite LightSource lighting code using new property modifiers
[ ] Write attire (wear) action code
[ ] Write open, close Action code
[ ] Write lock, unlock Action code
[ ] Transition die code into Action subclass (?)
[ ] Some more verbs: clean, push, shatter(?), unwield
[ ] Fix quantities (they are not currently being respected for get/drop actions)
[X] Death conditions
    [/] For player
        - Player do_die() is called, but graceful game shutdown is not yet done
    [X] For other Things
[ ] Make it easier for enum classes to be defined, to have an operator<< defined, and to have it exposed to Lua.
[ ] Light bleed across tiles
    - Simple convolution that bleeds a bit of light from a tile into adjacent ones, will make shadows way less sharp
[X] Split MessageLog into model/view (MessageLog and MessageLogPane)
[ ] Allow for scrolling back in MessageLog
[ ] Allow for lines with different colors (and fonts?) in MessageLog
[/] Show the "wielded" / "equipped" tiles in the Inventory
    - Doing a simple letter so far, will do nicer tiles down the line
    
[/] Create Thing::spill() method which dumps the contents of a Thing out into the Thing's location
    - Maybe allow a "do_spill" action that performs this purposely?
    - Each Thing that tumbles out should have do_collided_with(new_location) called on it (do_collided_with_floor?)

BIG THINGS
==========
[/] Localization
    - I originally thought about using boost::locale into the codebase, use for properly handling strings, but this may make Lua stuff problematic.
    - Instead I'm thinking of JSON files that map string IDs to strings in different languages. They can be parsed into property trees when the scripts are loaded.

[ ] Re-introduce the concept of facing direction...?
    - A "marching" entity would need to keep track of its current direction in order to keep moving that way. A local Lua variable would work, but leads to the problem of loads/saves not preserving the variable (as Lua state is not serialized on load/save).

[/] Implement GUILabel class
    [ ] Label should support left/center/right justification
    [ ] Label should handle text wrapping
    [ ] Change StatusArea to use GUILabel
    [ ] Change InventoryArea to use GUILabel

[/] Map creation driven via Lua scripts instead of C++ code

[ ] Add a way for monster types to register themselves in a vector that stores spawn information
    - Never / Single / Group
    - XP level for spawning
    - Spawn location (e.g. cave, town, etc)?
    
[ ] Implement the Attack action!

[ ] Let Lua get a Thing's inventory (as a table of ids)

[ ] Streamline Lua get/set of properties
    - We shouldn't require these get_[flag|value|string] functions for Lua; we should just be able to call get/set and have the C function deduce what we want. For setting:
        - 1 lua_Number --> value
        - 1 lua_Boolean --> bool
        - 1 lua_String --> string
        - 2 lua_Numbers --> sf::Vector2f
        - 4 lua_Numbers --> sf::Color        
    - Likewise, get can just push back however many return values are needed for the value.

[X] Revamp Actions
    - Actions should be split into the following stages:
        - "pending": The action is ready to be executed.
        - "pre_begin": Prior to the action being executed. Checks to see if the action is possible. Accounts for overall reaction time (based on Agility attribute) and waits before starting the action.
        - "in_progress": Starts the action; waits for the amount of time the action takes to execute. Switches to "post_finish" when completed.
        - "post_finish": Completes the action; waits for the recovery time after the action is completed. Switches to "processed".
        - "processed": Action is done, and the next action should be popped.  
    - Some actions have to be fudged; for example, "move". Obviously, in real life, the move would start at "begin", progress from tile A to tile B during "in_progress", and end up at "finish". However, being a tile-based game, moves are atomic from tile to tile. So the move immediately executes at the start of "in_progress". "in_progress" is the amount of time the move actually took. "post_finish" does nothing. This will best approximate what the player expects to happen -- if a monster is adjacent, about to attack, they can leap out of the way. (Of course, there's still the "pre_begin" Agility check, so they may not be fast enough.)

[ ] Mouse selection of GUIPanes, inventory items

[ ] List of available commands that apply when Things are selected
        
[ ] GUIPane animation for sliding in/out, flipping, expanding/shrinking

[ ] Settings option that chooses which attributes to show in StatusArea

[ ] Implement fog / variable opacity for sight
    - This actually isn't too difficult; we already have the "depth" parameter for do_recursive_visibility. It wouldn't be too hard to add a combined opacity number, and bail out if it exceeds a certain value.

[ ] Use std::async to parallelize visibility, light propogation
    - Requires making sure that the algorithm does not visit any one tile twice. Right now I think the 45/90-degree compass directions ARE visited twice, which would have to be rectified.
    - After that it should be as simple as wrapping octant calls inside std::async
    
MIND-BOGGLINGLY ENORMOUS THINGS
===============================
[ ] Implement saving/loading of the entire game state
    - I've *barely* started to do this, by writing serialization functions.

[/] Refactor rendering to allow for swapping out rendering engines

??? THINGS
==========
* How do we handle polymorphing?
    * A permanent polymorph is actually pretty easy; you just make a new Thing and then do set_player() on it.
    * Temporary polymorphs are far trickier; we need a way to stash the existing Thing somewhere, and then revert back to it at death.
        * Original form could be stashed in Limbo; the temporary polymorph would need to store its ThingId to know what to revert to
        * There's also the question of which attributes get copied over.


LIQUID TYPES
------------
* brilliant
* caustic
* effervescent
* foaming
* luminous
* milky
* murky
* oily
* sparkling
* viscous

LIQUID COLORS
-------------
fuchsia
crimson
scarlet
amber
golden
emerald
turquoise
cerulean
azure
indigo
violet
black

Monster Ideas
===============================================================================
cynicism elemental

Text Renderer Tokenizer (probably not needed if boost::locale is used)
===============================================================================
TextRendererState
TextRendererStateMachine
TextRendererPart
    TextRendererWord
    TextRendererWhitespace
    TextRendererToken
