# Thoughts on a Game Object/Material/Trait Crafting Model

## Definitions

- `Recipe` is the instructions to create an `Object`
- `Expression` is a logical expression represented as an object hierarchy
- `Object` is any entity of substance in the world, derived from a `Prototype`
- `Prototype` is the prototypical representation of a game `Object`
- `Material` represents a substance that `Object`s are made out of
- `Trait` is simply that -- a particular property of something

## Traits

- `Trait` is a key/value pair where the key is a string and the value can be a string, number, array of numbers, or boolean value
- `Trait`s are registered in an overall `TraitDictionary`
- `Trait`s can imply other `Trait`s

## Materials

- `Material` has 1-N `trait`s of type `Trait`

## Prototypes

- `Prototype` has 0-N `categories` of type `Prototype`
- Inherits the `Trait`s of its categories; `Trait`s of a higher-numbered `category` supercede those of a lower-numbered one
- `Prototype` has 0-N `traits` of type `Trait`; these `Trait`s supercede those of its `categories` if present
- _Autogenerated_: An array of `Recipe`s indexing those that output this prototype  

## Objects

- `Object` has one `prototype` of type `Prototype`
- `Object` has 1-N `materials` of type `Material`
- `Object` copies its `prototype`'s `Trait`s when created, and inherits its `material`'s traits
- `Material` traits should generally not overlap with `Prototype` traits, but where they do, the `Prototype` traits take precedence


## Expressions

- `Expression` is a Command object with one method, `execute`, which takes a JSON object as both input and output.
    + Reference Expressions
        * `Input(name: String) => Any` - Returns one of the inputs passed into the `Expression`.
        * `PrototypeOf(object: Object) => String` - Returns an object's prototype.
        * `MaterialsOf(object: Object) => Array[String]` - Returns an array of the object's material IDs.
        * `TraitsOf(object: Object) => Map[String => Any]` - Returns a dictionary of the object's traits.
    + Boolean Expressions
        * `Not(expression: Boolean) => Boolean` - Returns `true` if `expression` is `false`.
        * `Or(expressions: Array[Boolean]) => Boolean` - Returns `true` if any of `expressions` is `true`.
        * `And(expressions: Array[Boolean]) => Boolean` - Returns `true` if all of `expressions` are `true`.
        * `Xor(expressions: Array[Boolean]) => Boolean` - Returns `true` if only one of `expressions` is `true`.
    + Comparison Expressions
        * `Contains(array: Array, value: Any)` - Returns `true` if `value` is present in `array`.
        * `ContainsValue(map: Map, value: Any)` - Returns `true` if `value` is one of the values in `map`.
        * `EqualTo(left: Any, right: Any) => Boolean` - Returns `true` if `left` and `right` are equal.
        * `GreaterThan(left: Number, right: Number) => Boolean` - Returns `true` if `left` is greater than `right`.
        * `GreaterThanOrEqualTo` = `Or(EqualTo, GreaterThan)`
        * `LessThanOrEqualTo` = `Not(GreaterThan)`
        * `LessThan` = `Not(GreaterThanOrEqualTo)`
        * `IfThenElse(expression: Boolean, trueResult: Any, falseResult: Optional[Any])` = Returns `trueResult` if expression is `true`, and `falseResult` if it is `false` (or `nil` if `falseResult` is missing).


## Recipes

- `Recipe` has 1-N `input`s of type `ExpressionInput`
- `Recipe` has 1-N `output`s of type `RecipeOutput`
- `ExpressionInput` has the following members:
    + `expression` which is of type `Expression`
    + `arguments` which is a map of inputs to the expression, if needed.
    + **TODO** something about consumption of the item
- `RecipeOutput` has the following members:
    + `prototype` which is of type `StringExpression`; ``
    + `material` which is of type `StringExpression`
    + `chance` which is a percentage likelihood of generation
- `Recipe` tries all permutations of the input rules vs the inputs; they don't have to be explicitly specified as part of the recipe
- Example: Making an axe
    + input[0]
        * expression: PrototypeOf(object) == "stick"
    + input[1]
        * expression: PrototypeOf(object) == "axe_head"
    + output[0]
        * prototype: "axe"
        * material: MaterialOf(object[1])
- Example dependency: Making an axe head (stone)
    + input[0]
        * expression: TraitOf(object) == "chippable" 
    + input[1]
        * expression: PrototypeOf(object) == "hammer"

